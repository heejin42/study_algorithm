# ✏ LeetCode - Machine Learning 101
리트 코드의 머신러닝 관련 영문 자료를 읽고 정리하였다.
'How'는 그 두번째 챕터로 머신러닝의 구체적인 작동 방법에 대해 나와있다.

### Data, Data, Data!
머신러닝 workflow의 궁극적인 목표는 머신러닝 모델을 만드는 것이다. 그리고 우리는 데이터로부터 모델을 얻는다.
결과적으로 데이터는 모델이 이룰 수 있는 성능의 상한선을 결정짓는다. 특정 데이터에 적합하게 할 수 있는 모델은 많다. 
우리가 할 수 있는 최선의 노력은 데이터가 설정한 상한선에 최대한 접근하는 모델을 찾는 것이다.
우리는 모델이 데이터의 범위 밖의 무언가를 학습할 수 있다고 기대할 수는 없다.
> **Rule of thumb**: garbage in, garbage out.

![img](https://velog.velcdn.com/images/lhj99apr/post/8e9e495a-347f-4c39-9aee-5d4c714f4835/image.png)
눈 먼 남자와 코끼리의 비유로 위 내용을 설명해보겠다. 한번도 코끼리를 마주 한 적이 없는 눈먼 사람들의 그룹이 있고, 코끼리를 만짐으로써 어떻게 생겼을지 배우고 개념화하고자 했다.
그래서 각자 몸의 다리, 코, 꼬리 등의 부위를 만짐으로써 현실의 실체를 경험했지만 누구도 코끼리의 전체 그림을 그릴 수 없었다. 결론적으로 그들 중 누구도 실제 코끼리의 이미지를 배우지 못한 것이다. 

머신러닝 태스크로 돌아가보면, 학습 데이터는 코끼리의 다리나, 코와 같은 사진일 수 있지만 테스트 데이터는 코끼리 전체의 모습일 수 있다.
우리의 학습 모델이 이런 경우에 잘 작동하지 않는다는 것을 놀랍지 않게 알아낼 수 있다. 왜냐? 우리는 처음 현실에 가까운 높은 품질의 학습 데이터를 가지지 못했기 때문이다.

누군가는 데이터가 매우 중요하다면, 왜 'high-quality'의 데이터(코끼리 전체의 모습)를 주지 않았는지, 코끼리 몸의 일부 사진들을 주었는지 궁금할 것이다.
문제를 마주해보면 우리나 컴퓨터는 눈먼 사람과 같이 문제의 주요한 특징이 담긴 데이터를 모으는 데 어려움을 격는다. 기술적(데이터 프라이버시)와 같은 이유일 수도 있고, 단순히 그 문제를 바르게 이해하지 못했기 때문일 수도 있다.

현실 세계에서 우리에게 가장 유리한 것은 현실을 일부 반영하는 데이터라고 할 수 있으며, 조금 덜 유리한 것은 노이즈가 있는 데이터, 가장 안 좋은 케이스는 현실의 모순이 담긴 데이터 일 것이다.
머신러닝 알고리즘과 관계 없이, 너무 많은 노이즈가 있는 데이터나, 현실에 모슨되는 데이터는 아무것도 배울 수 없을 것이다.

<br>

### Machine Learning Workflow

앞에서는 머신러닝 모델의 개념을 명확히 배워보았다.
이번에는 머신러닝 모델을 구성하는 워크플로우에 대해 이야기해보겠다.

**Data-Centric Workflow (데이터 중심 워크플로)**
> 머신러닝 모델을 생성하는 워크플로우는 데이터 중심으로 이루어져 있다.

데이터가 머신머신 모델이 어떻게 생성될지 지시한다고 말해도 전혀 과장이 아니다.
아래 그래프는 머신러닝 프로젝트의 대표적인 워크플로우를 표현해놓았다.
![img](https://velog.velcdn.com/images/lhj99apr/post/4037892f-525e-45f7-9251-9f6fa5f6a58f/image.png)

데이터에서 시작해, 맨 처음 우리는 지도학습과 비지도학습 중 어떻게 풀 것인지 머신러닝 문제의 타입을 결정한다.
데이터가 라벨링 되어있고, 그 중 일부 데이터가 얻고자 원하는 속성을 포함하고 있다면 그것을 우리는 타깃 속성이라고 말한다.
예를 들어, 사진에 고양이가 있는지 없는지 말해주는 과제를 생각해보면, 있는지 없는 지에 대한 이진 데이터 값이 타깃 속성이 될 것이다.
만약 이 타킷 속성이 존재하고, 라벨링된 데이터가 있다면, 그것은 지도학습 문제가 되는 것이다.

그 다음으로 지도학습 머신러닝 알고리즘에서 우리는 예상 출력값에 따라 분류와 회귀 중 생성할 모델 타입을 정한다. 원하는 결과가 분리된 값이라면 분류 모델을 선택하고, 연속된 값이라면 회귀 모델을 선택한다.

모델 타입을 결정하고 나면, 데이터를 원하는 형식으로 변환하는 기능 엔지니어링을 한다.
기능 엔지니어링의 몇 가지 예를 살펴보겠다.

- 대부분 케이스에서 우리는 데이터를 학습용과 테스트용 두가지 그룹으로 나눈다. 학습 데이터셋은 모델을 학습시키는데에 사용되며, 테스트 데이터셋은 생성된 모델이 새로운 데이터에 적용할 수 있을 만큼 충분히 일반적인지 여부를 테스트하고 검증하는데에 쓰인다.
- 원본 데이터는 누락 값으로 불완전한 상태일 수 있다. 그러므로 누군가는 이런 누락 값을 평균과 같은 여러 전략을 통해 채워줘야 한다.
- 데이터셋은 나라, 성별 등과 같은 카테고리 속성을 가지기도 한다. 알고리즘의 한계가 있기 때문에 글자열 값을 숫자 값으로 바꿔주는 작업이 필요하다. 예를 들어, 선형 회귀 알고리즘은 실제 입력 값으로 백터값만 처리할 수 있다.

> 기능 엔지니어링은 일회적인 과정이 아니다. 워크플로우 내에서 반복적으로 기능 엔지니어링으로 돌아와 작업해야 하는 경우가 많다.

데이터가 준비되면, 우리는 머신러닝 알고리즘 중 하나를 선택하여 준비된 학습 데이터를 넣어준다. 이것이 우리가 말하는 학습 과정이다.

학습 과정의 마지막에서는 예약된 테스트 데이터로 데이트 과정을 거친다.

첫번째 학습 모델에서 만족하는 경우는 거의 드물다. 대부분 학습 과정으로 돌아가 모델의 파라미터 값들을 조정하는데 이것을 하이퍼-파라미터 튜닝이라고 말한다. 
"하이퍼"라고 하는 이유는 모델과 상호작용하는 바깥쪽 인터페이스의 파라미터라는 것을 강조하기 위해서다. 결국 이는 모델 안의 기본 매개변수들에 영향을 미치게 된다. 
예를 들어, 의사결정 트리 모델에서는 트리의 최대 높이가 하이퍼 파라미터다. 학습 전에 최대 높이를 수동으로 설정해놓으면, 학습 마지막에 의사결정 트리의 기본 매개변수인  가지와 잎 수를 제한할 수 있다.

> 우리가 알 수 있듯이, 머신러닝 워크플로우는 데이터를 중심으로 한 사이클의 과정을 보이고 있다.

---

### Underfitting VS. Overfitting
다음은 머신러닝 모델링 중 발생하는 과소적합과 과적합에 대해 알아보겠다.
분류나 회귀와 같은 지도학습 알고리즘에서는 생성 모델이 데이터에 잘 학습되지 않는 두가지 경우가 흔하게 발생한다. 바로 과소적합과 과적합이다.

지도학습 알고리즘의 중요한 측정 기준은 **일반화**로 학습 데이터로부터 생성된 모델이 새로운 다른 데이터에 얼마나 일반적으로 적용되는지에 대한 부분이다.]
모델이 과소적합, 과적합 되었다고 말할 때는 모델이 새로운 데이터에 대해서 일반적으로 잘 적용되지 않는다는 것을 의미한다.

모델이 학습 데이터로부터 잘 학습되었다는 것이 다른 데이터에도 일반적으로 잘 작동한다는 뜻은 아니다.
왜냐하면
1) 학습 데이터는 실제 세상에서 얻은 샘플일 뿐이며 현실의 일부만 대표할 뿐이다.
2) 우리가 수집한 데이터는 노이즈나 에러가 있을 수 있다. 학습 데이터에 완벽히 학습된 모델이라고 해도 데이터의 노이즈나 실수에 의해, 다른 모르는 데이터에 대해 예측할 때도 에러나 편향된 결과를 낼 수 있다

과소적합과 과적합에 대해 정의를 내리기 전에, 분류 모델에서 과소적합된 모델과 과적합된 모델 각각의 예시를 보자.
![img](https://velog.velcdn.com/images/lhj99apr/post/a8d11db8-a3bf-4f55-b1e8-40a15911e1c5/image.png)


**Underfitting(과소적합)**
과소적합된 모델은 학습 데이터로부터 잘 학습되지 않은, 실측 데이터에서 벗어난 경우다.
과소적합의 원인 중 하나는, 모델이 데이터에 대해 너무 단순하게 학습하여 데이터에 숨겨진 관계를 파악하지 못할 수 있다. 위 첫번째 그래프를 보면 분류의 두 카테고리의 경계가 선형적으로 매우 심플하게 생성되어 있어 잘못된 분류 결과를 낸다.
과소적합을 피하기 위한 대책으로, 우리는 학습 데이터 셋으로부터 더 정교한 모델을 생성하는 알고리즘을 선택할 수 있다.

**Overfitting(과적합)**
학습 데이터로부터 너무 잘 학습된 과적합 모델은 학습 데이터에서는 에러를 거의 내지 않지만 새로운 다른 데이터에 대해서는 일반적으로 잘 작동하지 않는다.

과소적합과는 반대로, 데이터의 모든 비트에 정교하게 학습된 모델은 노이즈나 에러의 함정에 빠질 수 있다. 위에서 세번째 그래프를 보면 학습 데이터 셋에 대해서는 분류 오류가 적지만, 새로운 데이터에 대해서는 비틀거리는 것을 볼 수 있다.

과소적합 케이스와 비슷하게 과적합을 피하기 위해서도, 우리는 학습 데이터셋에서 좀 더 일반적인 모델을 생성하는 알고리즘을 시도해볼 수 있다. 혹은 더 과적합 모델을 생성한 원래 알고리즘을 유지하는 대신, 정규화 과정을 알고리즘에 추가할 수 있다.

<br>

### Bias(편향) VS. Variance(분산)
이번 아티클에서는 앞에서 공부했던 과적합, 과소적합을 알아보는 요소인 bias(편향)과 variance(분산)에 대해 이야기하겠다.

시작하기 전, 아래 문장을 한번 읽어보자. 아직 무슨 의미인지 한번에 이해하지 못할 수도 있지만, 이 아티클을 다 읽고 나면 답을 찾을 수 있길 바란다.

> Bias(편향)은 같은 잘못된 것에 대해 지속적으로 학습하는 경향이다. Variance(분산)은 실제와 관계 없는 무작위 것들을 학습하는 경향이다.

편향과 분산을 정의하기 위해서는 먼저 main prediction의 의미를 정의해야 한다.
모델과 손실함수의 개념과 친숙한 사람은 이 부분을 뛰어넘어도 된다.

**Definitions**
학습 데이터 셋 s가 주어졌고, 머신러닝 알고리즘은 모델 F를 생성해낸다.
테스트 데이터 x1가 주어지면, 이 모델은 F(x1) = y1 이라는 예측을 생성한다.
학습 데이터 셋의 각각 샘플들은 두가지 요소로 이루어져 있다. x라는 샘플과 관련된 속성이 있고, t라는 예측 결과가 되는 타깃 속성이 있다.
예를 들어 학습 데이터 샘플이 x = (type='appartment', location='LA', surface='120m2')이고 타깃 값 t = (price='420,000$') 이 있다고 하자. 머신러닝 알고리즘의 업무는 각 속성에 적합한 가격을 예측하는 것이다.

학습 데이터 샘플 (x, t)가 주어지면 학습자(머신러닝 알고리즘)은 F(x)을 통해 예측을 생성한 다음, 손실함수 L(F(x), t)를 정의함으로써 예측값 F(x) 와 실제 값 t 사이의 차이로 발생한 비용을 정의한다. 큰 차이는 큰 손실을 발생시킨다. 만약 타깃 값이 수치 값이라면 일반적인 손실 함수는 L(F(x), t) = (F(x) - t)2 , 즉 제곱오차가 될 것이다. 
위 예시에서 만약 모델 F가 x1에 대해 410,000$ 라고 예측한다면 손실 함수의 결과는 (420,000 - 410,000)2 = 10의 8승이 될 것이다.

**Main Prediction**
> 손실 함수 L과 학습 데이터셋 S={s1, s2, s3..}가 주어진다면, 학습자(머신러닝 알고리즘)의 메인 예측은 y=argmin E(L(y, y'))로 정의된다.

각각의 학습 데이터셋 s에 대해 우리는 모델 F를 학습시킨다. 주어진 학습 샘플에 대해 우리는 각각의 F 모델의 예측 값에 대응되는 예측 y 값들의 세트가 생성된다. 메인 예측 y는 평균 손실값이 된다. 
특정 경우에 손실 함수가 평균제곱오차(MSE)일 때, L(y, y') = (y-y')2이며, 메인 예측은 예측의 평균 값이 된다.
> 우리는 메인 예측을 학습 샘플에 대해 머신러닝 알고리즘으로부터 기대되는 정답이라고 해석할 수 있다.

메인 예측의 개념에 대해 더 잘 이해하기 위해서는 학습 모델이 다트 던지기 게임을 한다고 상상해보자. 
플레이어가 다트를 던질 때마다, 다음 두가지 해당 활동이 포함될 것이다. 
1) 플레이어가 과녁을 조준한다. 학습자가 학습 데이터셋으로부터 모델을 학습하는 것으로 이해할 수 있다.
2) 플레이어가 다트를 던진다. 이것은 학습된 모델이 예측을 생성하는 것으로 이해할 수 있다. 
직관적으로 과녁은 예측의 대상이다. 과녁에 가까운 다트일수록 더 좋은 플레이어(학습자)이다.
그리고 플레이어는 다트를 던지기 전에, 스스로 질문을 던질 수 있다.
얼마나 많은 점수를 낼 수 있는가. 이것이 바로 메인 예측의 개념이 나타나는 부분이다.
베팅할 수 있는 최선의 추측이 학습자의 메인 예측이며, 과거 이뤘던 게임들을 통해 이뤘던 평균 점수로 근사할 수 있다. 예를 들어, 우리는 좋은 플레이어의 손에서 나온 다트가 과녁에서 너무 멀리 벗어나지 않을 것이라고 내기할 수 있다.
> 직관적으로 우리는 주요 예측을 학습자의 일반적인 경향(성과), 즉 플레이어가 게임에서 득점할 수 있는 예상 점수로 간주할 수 있다.

주요 예측을 배웠으니, 다음으로 편향과 분산의 개념을 정의해보겠다.

**Bias(편향)**
한마디로 학습자의 편향은 예제에 있어서 주요 예측(일반적인 경향)과 목표 속성의 실제 값(목표 값)의 차이로 발생하는 손실이다.
주요 예측이 목표 값에 가까울수록 손실이 적다. 학습자가 올바른 예측을 하는 모델을 생성할 가능성이 높을수록 학습자의 편향이 줄어든다.
정의에 따르면 학습자의 주요 예측은 학습자가 다양한 학습 데이터 세트에서 생성한 모든 모델의 평균 예측이다. 따라서 무한 학습 데이터 셋을 가졌다면, 주요 예측이 학습자의 특성과 연결된 상수 값으로 수렴할 것이라 가정할 수 있다. 학습자의 편향이 0이면, 학습자는 평균 예측이 원하는 목표 값인 여러 모델을 생성할 수 있다고 말할 수 있다.
만약 학습자가 높은 편향과 데이터로부터 무언가 배운다면, 우리는 그 학습자로부터 나온 모델이 잘못된 예측을 할 가능성이 높다고 말할 수 있다.

**Variance(분산)**
> 학습자(알고리즘)의 분산은 V(x)로 정의한다. 학습 데이터 셋에서 생성된 예측의 손실 값 목록에 대한 평균 함수로 이해할 수 있다.

한마디로, V(x)는 다른 학습 데이터 셋에 대해 주요 예측 변동으로 인해 발생하는 손실을 측정한다.
학습자의 성능이 안정적일수록 분산은 줄어든다. 다트 게임에서 분산이 높은 학습자는 같은 위치에 다트를 거의 맞추지 않는 실력이 안좋은 플레이어에 해당한다. 반면, 분산이 낮은 학습자는 과녁을 거의 놓치지 않는 실력이 좋은 플레이어에 해당할 수 있다.

분산은 예측의 실제 값과는 무관하며, 학습 데이터셋에 관계없이 항상 동일한 예측을 수행하는 학습자에 대해서는 0이 된다.
학습자의 분산이 높으면 학습자가 학습 데이터 셋에 매우 민감하다는 것을 알 수 있다. 학습 데이터의 작은 노이즈가 잘못된 예측을 생성하는 잘못된 모델로 이어질 수 있다는 것이다.

**편향-분산 좌표**
아래 그림을 보면 두 가지 차원으로 플롯을 그린다. x 차원은 분산, y 차원은 편향을 나타낸다.
이전에서 살펴보았던 다트 게임 예제에 따라 학습자는 다트 플레이어라고 가정하고, 칠판의 각 점은 학습자가 한 예측에 해당한다. 점의 과녁에 가까울수록 목표 값에 가까운 예측이다.
학습자를 다음과 같이 네 유형으로 분류할 수 있다.

![img](https://velog.velcdn.com/images/lhj99apr/post/51ca0064-9bc1-4aa7-895d-c28a12f1f683/image.png)

1) 이상적은 학습자는 플롯의 왼쪽 아래 부분에 위치하며, 낮은 편향과 낮은 분산을 가진다. 과녁을 거의 놓치지 않는 좋은 다트 플레이어다.
2) 이상적인 학습자 오른쪽에는 일부 점수는 낮지만, 다트가 모든 곳에 공평하게 있다. 이 학습자는 일반적으로는 일부 괜찮은 모델을 학습할 수 있지만, 성능은 그다지 유망하지 않다. 좋은 모델을 얻지 못하는 경우를 과적합이라고 하기도 하며, 모델이 관련없는 노이즈에 너무 맞추게 된다.
3) 플롯의 오른쪽 위를 보면, 높은 편향과 높은 분산을 가진 최악의 학습자가 있다. 이 학습자는 데이터에서 정보를 추출하지 못하고, 아무것도 배우지 못한다. 학습자가 생성하는 예측은 관련성이 없고(높은 편향) 전략이 없이 무작위로 추측한다(높은 분산).
4) 그 옆에 편향은 높지만 분산은 낮은 순진한 학습자가 있다. 이 학습자는 안정적인 출력을 생성하는 간단한 전략을 채택한다. 즉 너무 단순한 모델, 과소적합 모델이 되는 것이다.

**편향-분산 절충**
> 학습자가 생성한 모델의 복잡성에 따라 편향이 감소하고 분산이 증가한다.

모델의 복잡성과 편향-분산 사이의 상관관꼐는 다음 그래프에서 설명할 수 있다.
![img](https://velog.velcdn.com/images/lhj99apr/post/9572ab85-4d60-479d-b1fd-ce8505b55ea5/image.png)

위의 그래프를 통해 몇가지 정보를 알 수 있다.
- 모델이 더 복잡해지면 잠재적으로 학습 데이터셋에 더 잘 맞게 되므로, 편향이 줄어든다.
- 한편, 모델이 더 복잡해지면 모델이 데이터의 노이즈에 민감해지기 때문에 분산이 증가한다.
- 모델이 총 오류는 편향과 분산에 관계가 있다.

실제로 모델의 손실 함수가 제곱 오차일 때, 총 오차는 다음과 같이 분해할 수 있다.
Err(x) = Bias2 + Variance + Irreducible Error
우리는 위 함수의 연역 과정을 건너뛰지만 자세한 내용은 이 [페이지](https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff#Derivation)에서 알 수 있다.

위의 정의에 따르면, 우리는 좋은 학습자가 낮은 편향과 낮은 분산을 가지고 있다는 것을 알 수 있다. 그러나 두 요소는 서로 상반되기 때문에, 둘 다 갖는 것은 어렵다. 결과적으로 최상의 결과를 얻으려면 모델 복잡성 속에서 적당한 위치를 찾아야 한다.

> 학습자가 주어지면, 매개변수를 조정하여 편향과 분산을 조정할 수 있다.

예를 들어 분류 문제에 대해 의사 결정 트리를 구성하는 경우, 제약 조건 없이 의사 결정 트리가 노이즈 데이터를 포함한 학습 데이터 셋에 모두 맞도록 너무 커질 수 있다. 결과적으로 주어진 훈련 데이터셋에 대해서는 편향이 낮은 의사 결정 트리 모델을 얻을 수 있지만, 과적합되기 때문에 보이지 않는 데이터 세트에 대해서는 높은 편향과 분산이 나타날 수 있다. 문제를 완화하기 위해서는 결정 트리의 성장을 제한하는 몇가지 제약을 부과할 수 있다. 예를 들어, 트리가 성장할 수 있는 최대 깊이를 설정하면 학습 데이터셋에는 높은 편향이 발생할 수 있지만 일반화되도록 훈련되었기 때문에 보이지 않는 새로운 데이터 세트에서는 더 낮은 분산과 낮은 편향을 가진 모델을 얻을 수 있다.

### 결론
이 글에서는 학습자(머신러닝 알고리즘)의 특성인 편향과 분산의 개념을 명확히 해보았다.
이러한 특성들은 머신러닝 문제를 해결하기 위해 적용하는 시나리오에서 나타난다. 따라서 편향과 분산을 측정하려면 주어진 문제에 대해 학습 데이터셋을 적용해야한다.
학습자의 편향과 분산은 문제의 맥락(학습 데이터셋, 학습 과정, 손실 함수) 등을 통해 정의된다.
일반적으로 그런 맥락을 언급하지 않고, 학습자가 높은 편향, 높은 분산을 가지고 있다고 말하는 것은 공정하지 않다. 예를 들어, 선형 회귀 알고리즘은 이미지 분류 문제에 대해 나쁜 학습자일 수 있지만, 데이터 셋에 몇가지 속성이 포함된 간단한 분류 문제에서는 탁월할 수 있다.

문제가 주어지면 학습자의 편향과 분산도 고정되지 않는 경우가 많다. 편향과 분산 사이의 균형을 맞추기 위해 학습자와 매개변수를 조정할 수 있다. 전반적으로 학습자가 생성한 모델의 복잡성이 증가하면 편향은 감소하고 분산은 증가한다.

마지막으로 처음 넣었던 문장으로 이 글을 마무리하겠다.
> 편향은 동일한 잘못된 것을 지속적으로 학습하려는 학습자의 경향이다. 분산은 실제 신호와 관련 없는 무직위 항목을 학습하는 경향이다.

