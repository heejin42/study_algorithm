# 스파르타코딩클럽 코딩테스트 준비
### 코딩 테스트란?
주로 IT 및 프로그래밍 관련 채용에서 사용되는 시험 방법으로 기술 역량과 문제해결능력, 코드 구현 능력을 테스트 하는 것이다. 이 시험을 통해 알고리즘 이해도, 자료구조 이해도, 프로그래밍 언어 자체에 대한 이해도를 파악하고 특정 문제나 상황에 대한 논리적 이해 능력을 확인할 수 있다.

### 기업별 코딩 테스트 유형
대체로 인터넷 검색을 허용하며 플랫폼을 통해 시험을 응시한다. (HackerRank, LeetCode)
- 삼성 전자: 3시간, 2문제 중 1문제 커트라인, 완전 탐색 & 구현 & dfs/bfs & 시뮬레이션
- 카카오: 5시간, 7문제 중 3~4문제 커트라인, 그리디 & 구현 & 문자열 & 자료구조
- 라인: 2시간 5문제 중 2~3문제, 그리디 & 구현 & 문자열 & 탐색 & 다이나믹 프로그래밍

## 학습법 1 - 기술 역량
### 자료 구조
- Array/List
- Linked List
- Stack
- Queue
- Dequeue
- Priority queue
- Hash Table
- Graph
- Tree
- Heap *

### 알고리즘
- Simulation/Implementation (구현) *
- Search
- Sort *
- Greedy *
- Dynamic programming *
- Dijkstra *
- Floyd-Warshall
- Prim
- Kruscal
- DFS, BFS *

## 학습법 2 - 문제 해결 능력
주어진 제시문을 잘 이해하고 문제를 분석하여 해결책을 찾아내는 능력
-> 문제를 많이 풀어보면서 풀이를 말로 설명해보기
-> 그 과정에서 논리적으로 빈약한 부분, 내가 잘 모르는 부분을 찾을 수 있다.

## 학습법 3 - 코드 구현 능력
1. 기본 문법 학습
2. 기초 알고리즘 문제 풀이
3. 기출 문제 풀이
꾸준히 오래 풀 수 있도록 꾸준히 길게 동기 부여를 해야 한다.


### 코딩테스트
1. 문제 꼼꼼히 읽기
2. 각 입력값들의 범위 확인해서 시간복잡도 계산하기
3. 적절한 풀이 방법 생각해보기 -> dp, dfs, bfs, 단순 구현 등
4. 코드 작성
5. 엣지 케이스

# 
1. 구현문제 
2. 힙(Heap) 관련 문제 (우선순위큐)
3. 완전탐색 문제 (dfs,bfs, 투포인터)
4. DP 문제

# 시간복잡도
제한 시간이 1초 일 경우, N의 범위에 따른 시간 복잡도 선택
- N의 범위가 500: 시간 복잡도가 O(N^3) 이하인 알고리즘을 설계
- N의 범위가 2,000: 시간 복잡도가 O(N^2) 이하인 알고리즘을 설계
- N의 범위가 100,000: 시간 복잡도가 O(NlogN) 이하인 알고리즘을 설계
- N의 범위가 10,000,000: 시간 복잡도가 O(N) 이하인 알고리즘을 설계
- N의 범위가 10,000,000,000: 시간 복잡도가 O(logN) 이하인 알고리즘을 설계

# 

변수에 사용할 수 있는 함수 찾기 -> dir(변수)
함수명과 변수명을 잘 정의해야 한다.

우선순위 큐 -> from queue import PriorityQueue, put(), get() -> O(logn) / import heapq, heap=[], heapq.heappush(heap, s), heapq.heappop(heap)
양방향 큐 -> from collections import deque, append(), pop()

sort() -> nlogn

## 1. 완전 탐색 문제
시간 복잡도 유의해서 효율적인 풀이를 생각해야된다.

### 투 포인터
-> 부분합인 경우, 투 포인터로 구하기, 이분탐색과 비슷하지만 0, 0 혹은 0, 1에서 출발한다는 점
참고 - /Users/leeheejin/study/baekjoon/BS/1365.꼬여있는전깃줄.py

### 이분탐색
def binary_search(arr, tgt):
    left, right = 0, len(arr)-1
    while left < right:
        mid = (left + right) // 2
        if arr[mid] > tgt:
            left = mid + 1
        else:
            right = mid
    return right

### dfs
```python
def dfs(x, idx):
    global visited
    for i in t_graph[idx]:
        if visited[x][i] == 0:
            visited[x][i] = 1
            visited[i][x] = 1
            dfs(x, i)
    return s_list
```    
### bfs
deque, heapq 등을 이용해서 풀이

## 2. 힙 관련 문제
heaqp을 잘 사용해서 구현하도록

## 3. DP 문제
함수식을 명확히 정의해놓고 구현하자. 예시로 피보나치 수열 구하는 문제
```python
n = int(input())
dp = [0 for _ in range(n+1)]
dp[1] = 1
for i in range(2, n+1):
    dp[i] = dp[i-1] + dp[i-2]
print(dp[n])
```
## 4. 단순 구현 문제
변수명을 잘 사용해야 혼동이 없다. 


### 소수 찾기 함수
```python
def is_prime(n):
    if n == 0 or n == 1:
        return False
    for i in range(2, n):
        if n%i == 0:
            return False
    return True

def prime_nums(n):
    arr = [i for i in range(n+1)]
    for i in range(2, n+1):
        if arr[i] == 0:
            continue
        for j in range(i*i, n+1, i):
            arr[j] = 0
    return [i for i in arr[2:] if arr[i]]   
```

## itertools
combinations, permutations, product 세 메소드 모두 generator이기 때문에 list()로 캐스팅하여 다른 곳에 저장 해두지 않으면 한 번의 루핑 이후 사라지게 된다.

### combinations
중복을 허용하지 않고 모든 경우의 조합을 생성한다.
```python
from itertools import combinations
_list = [1, 2, 3]
combi = list(combinations(_list, 2))
```
여기서 중복 조합을 원한다면 from itertools import combinations_with_replacement 하면 된다.

### permutations
중복을 허용하고 모든 경우의 순열을 표현한다.
```python
from itertools import permutations
_list = [1,2,3]
perm = list(permutations(_list, 2))
```

### product
데카르트 곱이라고도 하는 cartesian product를 표현할 때 사용하는 메소드, 두개 이상 리스트의 요소들끼리 모든 조합을 구할 수 있다.

```python
from itertools import product

_list = ["012", "abc", "!@#"]
pd = list(product(*_list))
# [('0', 'a', '!'), ('0', 'a', '@'), ('0', 'b', '!'), ('0', 'b', '@'), ('1', 'a', '!'), ('1', 'a', '@'), ('1', 'b', '!'), ('1', 'b', '@')]

from itertools import product

iter = [1,2,3,4]
for i in product(iter, repeat=2):
    print(i)
# [(1,1), (1,2), (1,3), (1,4), (2,1), (2,2), (2,3), (2,4)]    

```